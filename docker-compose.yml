# File: FFA/docker-compose.yml

services:
  api_server:
    build:
      context: . # Build context remains the project root (FFA/)
      dockerfile: App/api_server/Dockerfile
    ports:
      - "8080:8080"
    volumes:
      # Mount the api_server source code to its location relative to the container's /app WORKDIR.
      # This ensures live code changes are reflected correctly.
      - ./App/api_server:/app/api_server
      # The backend volume mount is already correctly configured if api_server depends on it.
      - ./App/backend:/app/backend
    env_file:
      - .env
    # Override the Dockerfile's CMD for development with --reload.
    # The module path is now 'api_server.main:app'.
    command: uvicorn api_server.main:app --host 0.0.0.0 --port 8080 --reload
    depends_on:
      - backend

  backend:
    build:
      context: . # Set build context to the project root (FFA/)
      dockerfile: App/backend/Dockerfile # Path to the Dockerfile relative to the context
    volumes:
      # Mount the backend source code for development.
      # Assuming the WORKDIR in backend's Dockerfile is /app/backend.
      - ./App/backend:/app/backend
    env_file:
      - .env # Load environment variables from a .env file at the project root
    # Add a specific command here to start your backend service if it's not a web server.
    # For example: command: ["python", "run_processor.py"]

  frontend:
    build:
      context: ./frontend # Set build context to the frontend application directory
      dockerfile: Dockerfile # Dockerfile is now expected directly in that context
    ports:
      - "5173:5173"
    volumes:
      - ./frontend:/app # This path still works as it's relative to the docker-compose.yml location (project root)
      - /app/node_modules
    command: ["npm", "run", "dev"]